### LeetCode 207. Course Schedule

[Question](https://leetcode.com/problems/course-schedule/)
| [Solution-1 (BFS)](https://leetcode.com/submissions/detail/514037898/)
| [Solution-2 (DFS)](https://leetcode.com/submissions/detail/584643587/)

#### C++

##### Solution - 1 (BFS)
```c++
// Time Complexity: O(N+E) N = nodes, E = edges
// Space Complexity: O(N+E) for adj list + O(N) visited/in_degree + O(N) queue

class Solution {
public:
    bool canFinish(int n, vector<vector<int>>& v) {
        vector<int> in_deg(n, 0);
        vector<int> graph[n];
        
        for(int i=0;i<v.size();i++)
            graph[v[i][1]].push_back(v[i][0]),
            in_deg[v[i][0]]++;
        
        queue<int> q;
        int cnt = 0;
        
        for(int i=0;i<n;i++)
            if(in_deg[i] == 0)
                q.push(i);
        
        while(!q.empty()){
            cnt++;
            int node = q.front(); q.pop();
            
            for(auto k: graph[node])
                if(--in_deg[k] == 0)
                    q.push(k);
        }
        
        return (cnt == n);
    }
};
```

##### Solution - 2 (DFS)
```c++
// Time Complexity: O(N+E) N = nodes + E = edges
// Space Complexity: O(N+E) for adj + O(N) visited + O(N) recursion stack

class Solution {
    bool isCycle(int node, vector<int>& visited, vector<vector<int>>& adj){
        if(visited[node] == 1) return true;
        
        visited[node] = 1;
        
        for(auto k: adj[node])
            if(visited[k] != 2 && isCycle(k, visited, adj))
                return true;
        
        visited[node] = 2;
        return false;
    }
public:
    bool canFinish(int n, vector<vector<int>>& v) {
        vector<vector<int>> adj(n);
        
        for(int i=0;i<v.size();i++)
            adj[v[i][1]].push_back(v[i][0]);
        
        vector<int> visited(n, 0);
        for(int i=0;i<n;i++)
            if(visited[i] == 0 && isCycle(i, visited, adj))
                return false;
        
        return true;
    }
};
```